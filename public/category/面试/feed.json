{
    "version": "https://jsonfeed.org/version/1",
    "title": "七音 • All posts by \"面试\" category",
    "description": "路漫漫其修远兮，吾将上下而求索",
    "home_page_url": "https://qiyins.cn",
    "items": [
        {
            "id": "https://qiyins.cn/computer/questions/course-1/web_questions/",
            "url": "https://qiyins.cn/computer/questions/course-1/web_questions/",
            "title": "web面试题",
            "date_published": "2020-12-17T04:05:00.000Z",
            "content_html": "<h2 id=\"get和post的区别\"><a class=\"anchor\" href=\"#get和post的区别\">#</a> Get 和 Post 的区别</h2>\n<p>get 和 post 都是 http 的请求方式，用户通过不同的请求方式来完成对资源的不同操作，get、post、put、delete 分别对应着资源的查、改、增、删四个操作，一般来说 get 用来获取资源，post 用于更新资源</p>\n<blockquote>\n<ol>\n<li><strong>get 请求提交的数据会在地址栏显示出来，post 请求不会</strong></li>\n<li><strong>由于地址栏长度有限，导致 get 传输的数据有限，而 post 不会</strong></li>\n<li><strong>安全性，post 安全性比 get 高</strong></li>\n</ol>\n</blockquote>\n<h2 id=\"对servlet的理解\"><a class=\"anchor\" href=\"#对servlet的理解\">#</a> 对 Servlet 的理解</h2>\n<blockquote>\n<p><strong>Servlet 是用 Java 程序编写的服务端程序，而这些 Servlet 都要实现 Servlet 接口，其主要功能是用于交互式的浏览和修改数据，生成动态网页</strong></p>\n<p><strong>HttpServlet 重写 doget 和 dopost 方法或者重写 service 方式可以实现对 get 和 post 请求的响应</strong></p>\n</blockquote>\n<h2 id=\"servlet的生命周期\"><a class=\"anchor\" href=\"#servlet的生命周期\">#</a> Servlet 的生命周期</h2>\n<blockquote>\n<p>加载 Servlet 的生命周期，调用 init () 进行初始化，然后调用 service () 方法来处理客户端的请求，最后调用 destroy () 终止</p>\n</blockquote>\n<h2 id=\"forward与redirect的区别\"><a class=\"anchor\" href=\"#forward与redirect的区别\">#</a> forward 与 redirect 的区别</h2>\n<blockquote>\n<ol>\n<li>forward 地址栏不会发生改变，redirect 地址栏会发生改变</li>\n<li>forward 是服务器上的行为，redirect 是客户端的行为</li>\n<li>forward 是一次请求完成的，redirect 是两次请求完成的</li>\n<li>forward 效率较高</li>\n</ol>\n</blockquote>\n<h2 id=\"jsp与servlet的相同点与不同点\"><a class=\"anchor\" href=\"#jsp与servlet的相同点与不同点\">#</a> JSP 与 Servlet 的相同点与不同点</h2>\n<blockquote>\n<p>相同点：JSP 是 Servlet 的扩展，所有的 JSP 文件最终都会被翻译成一个继承 HttpServlet 类，也就是说 JSP 最终也是一个 Servlet</p>\n<p>不同点：JSP 侧重于视图，Servlet 侧重于控制逻辑</p>\n</blockquote>\n<h2 id=\"jsp的九大内置对象与四大作用域\"><a class=\"anchor\" href=\"#jsp的九大内置对象与四大作用域\">#</a> JSP 的九大内置对象与四大作用域</h2>\n<p>九大内置对象</p>\n<blockquote>\n<p><strong>Request：客户端的请求</strong></p>\n<p><strong>Response：网页传回客户端的响应</strong></p>\n<p><strong>PageContext：网页属性的管理</strong></p>\n<p><strong>Session：会话</strong></p>\n<p><strong>Application：servlet 正在执行的内容</strong></p>\n<p><strong>Out：传递回应的输出</strong></p>\n<p><strong>Config：servlet 的架构不见</strong></p>\n<p><strong>Page：Jsp 网页本身</strong></p>\n<p><strong>Exception：针对错误的网页</strong></p>\n</blockquote>\n<p>四大作用域</p>\n<blockquote>\n<p><strong>page：只在一个页面保留数据</strong></p>\n<p><strong>request：只在一个请求中保存数据</strong></p>\n<p><strong>Session：再一次会话中保存数据，仅供单个用户使用</strong></p>\n<p><strong>Application：在整个服务器中保存数据，全部用户共享</strong></p>\n</blockquote>\n<h2 id=\"cookie与session的区别\"><a class=\"anchor\" href=\"#cookie与session的区别\">#</a> Cookie 与 Session 的区别</h2>\n<p><strong>cookie 和 session 都是会话跟踪技术</strong></p>\n<p>不同点</p>\n<blockquote>\n<ol>\n<li><strong>cookie 的数据是存在客户端的，session 的数据是存在服务器上的</strong></li>\n<li><strong>cookie 是不安全的</strong></li>\n<li><strong>session 会在一定时间内存放在服务器上，当访问增多时，会占用服务器的性能</strong></li>\n<li><strong>单个 cookie 的保存数据不能超过 4k, 很多浏览器一个站点最多存放 20 个 cookie</strong></li>\n</ol>\n</blockquote>\n<p>建议</p>\n<blockquote>\n<p><strong>将登录信息等重要信息保存在 session 中，其他信息如需保留，可以放在 cookie 中，如：购物车</strong></p>\n<p><strong>购物车最好使用 cookie，范式 cookie 实在客户端禁用的，只是要我们需要使用 cookie + 数据库的方式实现，当从 cookie 中不能取出数据时，就从数据库中取</strong></p>\n</blockquote>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "https://qiyins.cn/computer/questions/course-1/mysql/",
            "url": "https://qiyins.cn/computer/questions/course-1/mysql/",
            "title": "数据库面试题",
            "date_published": "2020-12-17T04:04:00.000Z",
            "content_html": "<h2 id=\"数据库的分类\"><a class=\"anchor\" href=\"#数据库的分类\">#</a> 数据库的分类</h2>\n<blockquote>\n<p><strong>非关系数据库：mysql、oracle、sqlserver 等</strong></p>\n<p><strong>关系型数据库：redis、memcache、mongodb、hahdoop 等</strong></p>\n<p><strong>redis：键值对数据库</strong></p>\n<p><strong>mongodb：文档数据库</strong></p>\n</blockquote>\n<h2 id=\"数据库三范式\"><a class=\"anchor\" href=\"#数据库三范式\">#</a> 数据库三范式</h2>\n<p>范式就是规范，就是在关系型数据库设计表时要遵循的规范</p>\n<p>要想满足第二范式就必须满足第一范式，要想满足第三范式就必须满足第二范式</p>\n<blockquote>\n<p><strong>第一范式：要求属性具有原子性，不可再分解</strong></p>\n<p><strong>第二范式：每一行必须被唯一标识（主键）</strong></p>\n<p><strong>第三范式：任何字段不能由其他字段派生出来，要求字段没有冗余（外键）</strong></p>\n</blockquote>\n<h2 id=\"事务四个基本特性\"><a class=\"anchor\" href=\"#事务四个基本特性\">#</a> 事务四个基本特性</h2>\n<p>事务是并发控制的单位，是用户定义的一个操作序列，这些操作要么都做要么都不做，是一个不可分割的工作单位</p>\n<blockquote>\n<ol>\n<li>\n<p><strong>原子性（A）</strong></p>\n<p><strong>一个事务要么完整执行，要么就不执行</strong></p>\n</li>\n<li>\n<p><strong>一致性（C）</strong></p>\n<p><strong>底层数据存储的完整性</strong></p>\n</li>\n<li>\n<p><strong>隔离性（I）</strong></p>\n<p><strong>事务必须在不干扰其他进程或事务的前提下独立完成</strong></p>\n</li>\n<li>\n<p><strong>持久性（D）</strong></p>\n<p><strong>某个事务的执行过程中，对数据所做的所有改动都必须再事务成功结束前保存至某种物理存储设备</strong></p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"事务的隔离级别\"><a class=\"anchor\" href=\"#事务的隔离级别\">#</a> 事务的隔离级别</h2>\n<blockquote>\n<p><strong>脏读：A 查询 B 修改后问提交的数据，当 B 回滚时，A 查询的数据是无效的</strong></p>\n<p><strong>不可重复读：A 在第一次查询用户甲的信息，B 将用户甲的信息修改并提交；A 再次读取用户甲的信息，A 两次获取的信息不同则称为 “不可重复读”</strong></p>\n<p><strong>幻读：A 查询用户数量时，当 B 新增或删除用户时，A 再次获取用户数量时，两次数量不一致，则称为 “幻读”</strong></p>\n<p><strong>注意：“不可重复读” 与 “幻读” 的区别在于，不可重复读强调的是数据信息的改变，幻读强调的是数量上的改变</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">读未提交 (Read Uncommitted)</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">读已提交 (Read Committed)</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">可重复读 (Repeated Read)</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">串行化 (Serializable)</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n</tbody>\n</table>\n<p><strong>以上四种隔离级别，串行化的级别最高，读未提交的级别最低，级别越高，效率越低</strong></p>\n<p><strong>MySQL 支持以上四种隔离级别，默认的隔离级别是可重复度</strong></p>\n<p><strong>Oracle 数据库只支持串行化和读已提交 ，默认是读已提交；</strong></p>\n</blockquote>\n<h2 id=\"mysql最大的默认连接数\"><a class=\"anchor\" href=\"#mysql最大的默认连接数\">#</a> Mysql 最大的默认连接数</h2>\n<blockquote>\n<p><strong>100</strong></p>\n</blockquote>\n<p>为什么需要最大连接数？</p>\n<blockquote>\n<p><strong>特定服务器上面数据库最多只能支持一定数目同时连接</strong></p>\n</blockquote>\n<h2 id=\"mysql分页oracle分页\"><a class=\"anchor\" href=\"#mysql分页oracle分页\">#</a> Mysql 分页？Oracle 分页</h2>\n<p>为什么需要分页？</p>\n<blockquote>\n<p><strong>当有很多数据，一个页面不可能显示为所有数据，需要进行分段显示</strong></p>\n</blockquote>\n<p>mysql 使用了 limit 关键字来限制查询条数</p>\n<p>oracle 使用了 rownum 三层嵌套循环</p>\n<h2 id=\"对jdbc的理解\"><a class=\"anchor\" href=\"#对jdbc的理解\">#</a> 对 JDBC 的理解</h2>\n<blockquote>\n<p><strong>他就是 Java 与数据库建立连接的桥梁或插件，用 Java 代码就能操作数据库的增删查改、存储过程、事务等</strong></p>\n</blockquote>\n<h2 id=\"写一个简单的jdbc程序\"><a class=\"anchor\" href=\"#写一个简单的jdbc程序\">#</a> 写一个简单的 JDBC 程序</h2>\n<h3 id=\"操作步骤\"><a class=\"anchor\" href=\"#操作步骤\">#</a> 操作步骤</h3>\n<blockquote>\n<ol>\n<li><strong>加载驱动 (com.mysql.jdbc.Driver)</strong></li>\n<li><strong>获取参数 (DriverManager.getConnection (url,username,password))</strong></li>\n<li><strong>设置参数 (Statement PrepareStatement)</strong></li>\n<li><strong>执行 (execute)</strong></li>\n</ol>\n</blockquote>\n<h3 id=\"例子\"><a class=\"anchor\" href=\"#例子\">#</a> 例子</h3>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.mysql.cj.jdbc.Driver\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token class-name\">String</span> url <span class=\"token operator\">=</span> <span class=\"token string\">\"jdbc:mysql://localhost:3306/user?serverTimezone=GMT\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token class-name\">String</span> username <span class=\"token operator\">=</span> <span class=\"token string\">\"root\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token class-name\">String</span> password <span class=\"token operator\">=</span> <span class=\"token string\">\"123456\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token class-name\">Connection</span> connection <span class=\"token operator\">=</span> <span class=\"token class-name\">DriverManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConnection</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>username<span class=\"token punctuation\">,</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token class-name\">String</span> sql <span class=\"token operator\">=</span> <span class=\"token string\">\"select * from user\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token class-name\">PreparedStatement</span> preparedStatement <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span><span class=\"token function\">prepareStatement</span><span class=\"token punctuation\">(</span>sql<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token class-name\">ResultSet</span> resultSet <span class=\"token operator\">=</span> preparedStatement<span class=\"token punctuation\">.</span><span class=\"token function\">executeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>resultSet<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>resultSet<span class=\"token punctuation\">.</span><span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\" \"</span><span class=\"token operator\">+</span>resultSet<span class=\"token punctuation\">.</span><span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>connection<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>preparedStatement<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>resultSet<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"preparedstatement相比于statement的好处\"><a class=\"anchor\" href=\"#preparedstatement相比于statement的好处\">#</a> PreparedStatement 相比于 statement 的好处</h2>\n<blockquote>\n<ol>\n<li><strong>PreparedStatement 是预编译的，比 statement 快</strong></li>\n<li><strong>代码的可读性和可维护性高</strong></li>\n<li><strong>可以防 SQL 注入</strong></li>\n</ol>\n</blockquote>\n<h2 id=\"数据库连接池的作用\"><a class=\"anchor\" href=\"#数据库连接池的作用\">#</a> 数据库连接池的作用</h2>\n<blockquote>\n<ol>\n<li><strong>限定数据库的连接个数，进行统一的连接管理</strong></li>\n<li><strong>节约资源</strong></li>\n<li><strong>加快响应速度</strong></li>\n</ol>\n</blockquote>\n<h2 id=\"数据库优化\"><a class=\"anchor\" href=\"#数据库优化\">#</a> 数据库优化</h2>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "https://qiyins.cn/computer/questions/course-1/mybatis/",
            "url": "https://qiyins.cn/computer/questions/course-1/mybatis/",
            "title": "Mybatis面试题",
            "date_published": "2020-12-17T04:01:00.000Z",
            "content_html": "<h3 id=\"什么是mybatis\"><a class=\"anchor\" href=\"#什么是mybatis\">#</a> 什么是 Mybatis</h3>\n<blockquote>\n<p>Mybatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制 SQL、存储过程以及高级映射</p>\n<p>Mybatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO 为数据库中的记录</p>\n</blockquote>\n<h3 id=\"和的区别\"><a class=\"anchor\" href=\"#和的区别\">#</a> #{} 和 ${} 的区别</h3>\n<blockquote>\n<p>#{} 是占位符，预编译处理；${} 是拼接符，字符串替换；</p>\n<p>处理 #{} 时，#{} 传入参数是以字符串传入，会将 #{} 替换为？，调用 PrepareStatement 的 set 方法进行赋值</p>\n<p>变量替换后 #{} 对应的变量自动加上单引号 ''，${} 对应的变量不会加上单引号 ''；</p>\n<p>#{} 可以有效的防止 SQL 注入，提高系统安全</p>\n</blockquote>\n<h3 id=\"一级缓存和二级缓存\"><a class=\"anchor\" href=\"#一级缓存和二级缓存\">#</a> 一级缓存和二级缓存</h3>\n<blockquote>\n<p>一级缓存：是 Session 缓存，是基于 HashMap 存储的，作用域为 SqlSession 范围的，默认是打开一级缓存</p>\n<p>二级缓存：是 namespace 缓存，是基于 HashMap 存储的，作用域为 Mapper 的，默认不开启</p>\n</blockquote>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "https://qiyins.cn/computer/questions/course-1/springmvc_questions/",
            "url": "https://qiyins.cn/computer/questions/course-1/springmvc_questions/",
            "title": "SpringMVC面试题",
            "date_published": "2020-12-17T03:59:00.000Z",
            "content_html": "<h3 id=\"springmvc的执行流程\"><a class=\"anchor\" href=\"#springmvc的执行流程\">#</a> springmvc 的执行流程</h3>\n<blockquote>\n<ol>\n<li>发送请求到前端控制器 DispatcherServlet</li>\n<li>前端控制器请求处理映射器 HandlerMapping 查找 Handler</li>\n<li>处理映射器向前端控制器返回 Handler</li>\n<li>前端控制器调用处理适配器去执行 Handler</li>\n<li>Handler 执行完给适配器返回 ModelAndView</li>\n<li>处理适配器向前端控制器返回 ModelAndView</li>\n<li>前端控制器请求视图解析器 ViewResolver 去进行视图解析</li>\n<li>视图解析器向前端控制器返回 View 视图</li>\n<li>前端控制器进行视图渲染</li>\n<li>前端控制器向用户响应结果</li>\n</ol>\n</blockquote>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "https://qiyins.cn/computer/questions/course-1/java_quetsions/",
            "url": "https://qiyins.cn/computer/questions/course-1/java_quetsions/",
            "title": "Java面试题",
            "date_published": "2020-12-15T11:21:00.000Z",
            "content_html": "<h2 id=\"java基础\"><a class=\"anchor\" href=\"#java基础\">#</a> Java 基础</h2>\n<h3 id=\"java跨平台原理\"><a class=\"anchor\" href=\"#java跨平台原理\">#</a> Java 跨平台原理</h3>\n<blockquote>\n<p>Java 对于不同系统、不同版本、不同位数的 Java 虚拟机来屏蔽不同的系统指令集差异而对外提供统一的接口</p>\n</blockquote>\n<h3 id=\"jdk-jre-jvm的关系\"><a class=\"anchor\" href=\"#jdk-jre-jvm的关系\">#</a> JDK、JRE、JVM 的关系</h3>\n<blockquote>\n<p><strong>JDK (java development toolkit)：Java 开发工具包</strong></p>\n<p>是 java 的核心，包括了 java 运行环境，一堆 java 工具（javac、java、jdb）和 java 基础类库（javaAPI 包括 rt.jar）</p>\n<p><strong>JRE (java runtime environment)：Java 运行环境</strong></p>\n<p>所有的 java 程序都要在 JRE 下才能运行，包括 JVM 和 Java 核心类库和支持文件，与 JDK 相比不包含开发工具（编译器、调试器和其他工具）</p>\n<p><strong>JVM (java virtual mechinal)：Java 虚拟机</strong></p>\n<p>JVM 是 JRE 的一部分，他是一个虚拟出来的计算机，JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 指令集或 OS 的系统调用</p>\n</blockquote>\n<h3 id=\"面向对象的特征\"><a class=\"anchor\" href=\"#面向对象的特征\">#</a> 面向对象的特征</h3>\n<p>四个：封装、抽象、继承、多态</p>\n<blockquote>\n<p><strong>封装：将客观的事物封装成抽象的类，并且将自己类中的属性私有化，只对外提供 set 和 get 方法来进行属性的赋值和取值</strong></p>\n<p><strong>继承：子类继承父类，子类可以使用父类的所有功能，并且在无需改变父类的情况下能对这些功能进行扩展</strong></p>\n<p><strong>多态：允许相同或不同子类型的对象对同一消息作出不同的响应，如重载和重写</strong></p>\n</blockquote>\n<h3 id=\"访问修饰符publicprivateprotected以及默认时的区别\"><a class=\"anchor\" href=\"#访问修饰符publicprivateprotected以及默认时的区别\">#</a> 访问修饰符 public,private,protected, 以及默认时的区别</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修饰符</th>\n<th style=\"text-align:center\">当前类</th>\n<th style=\"text-align:center\">同包</th>\n<th style=\"text-align:center\">子类</th>\n<th style=\"text-align:center\">其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">public</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">protect</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">default</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">private</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"基本数据类型包装类型\"><a class=\"anchor\" href=\"#基本数据类型包装类型\">#</a> 基本数据类型，包装类型</h3>\n<p>基本数据类型有八种</p>\n<blockquote>\n<p><strong>byte、short、int、long、char、boolean、float、double</strong></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">占用字节</th>\n<th style=\"text-align:center\">取值范围</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">包装类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">只有 true 和 false</td>\n<td style=\"text-align:center\">true、false</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">Boolean</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">1 (8 位）</td>\n<td style=\"text-align:center\">-128~127</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Byte</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">2 (16 位)</td>\n<td style=\"text-align:center\">-32768~32767</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Short</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">4 (32 位)</td>\n<td style=\"text-align:center\">-2<sup>31~2</sup>31-1</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">-2<sup>63~2</sup>63-1</td>\n<td style=\"text-align:center\">0.0l</td>\n<td style=\"text-align:center\">Long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">3.4E-45~1.4E38</td>\n<td style=\"text-align:center\">0.0f</td>\n<td style=\"text-align:center\">Float</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">4.9E-324~1.8E308</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Double</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">0~65535</td>\n<td style=\"text-align:center\">\\u0000 (空格)</td>\n<td style=\"text-align:center\">Character</td>\n</tr>\n</tbody>\n</table>\n<p>包装类型：每一个基本数据类型都一一对于一个包装类型</p>\n<p>java 是一个面向对象的语言，而基本数据类型不具备面向对象的特征</p>\n<h3 id=\"拆箱和装箱\"><a class=\"anchor\" href=\"#拆箱和装箱\">#</a> 拆箱和装箱</h3>\n<blockquote>\n<p><strong>装箱：把基本数据类型转化为对应的包装类型</strong></p>\n<p><strong>Integer i = 1;</strong></p>\n<p><strong>自动装箱实际上会在编译时会调用 Integer.valueOf () 方法来装箱</strong></p>\n<p><strong>拆箱：把包装类型转换为基本数据类型</strong></p>\n<p><strong>int j = i;</strong></p>\n<p><strong>实际上在编译时会调用 intValue () 方法来拆箱</strong></p>\n</blockquote>\n<h3 id=\"和equals的区别\"><a class=\"anchor\" href=\"#和equals的区别\">#</a> == 和 equals 的区别</h3>\n<blockquote>\n<p><strong>== 用来判断两个变量之间的值是否相等，变量可分为基本数据变量和引用类型，如果比较的是基本数据类型，那么就是比较他们的值是否相等，如果比较的是引用类型，那么比较的是他们引用的内存地址</strong></p>\n<p><strong>equals 不能用于作用与基本数据类型的变量，他继承至 Object 类，比较的是是否是同一对象，如果没有对 equals 方法进行重写，则比较的是引用类型变量所指向对象的地址</strong></p>\n</blockquote>\n<h3 id=\"重写equals为何要重写hashcode\"><a class=\"anchor\" href=\"#重写equals为何要重写hashcode\">#</a> 重写 equals 为何要重写 hashcode</h3>\n<blockquote>\n<ol>\n<li><strong>使用 hashcode 方法提前校验，可以避免每一次对比都调用 equals 方法，提高效率（因为 hashcode 不等，equals 一定不等）</strong></li>\n<li><strong>为了保证是同一对象，如果重写了 equals 方法，而没有重写 hashcode 方法，会出现 equals 相等，hashcode 不相等的情况，重写 hashcode 方法就是为了避免这种情况发生</strong></li>\n</ol>\n</blockquote>\n<h3 id=\"stringstringbuilderstringbuffer的区别\"><a class=\"anchor\" href=\"#stringstringbuilderstringbuffer的区别\">#</a> String，StringBuilder，StringBuffer 的区别</h3>\n<blockquote>\n<p><strong>String 是字符串常量，其值不能改变，底层是使用了一个不可变的数组对象 (final char [])</strong></p>\n<p><strong>StringBulider 是线程不安全的，其值可以改变，速度快，底层是使用了一个可变的数组对象（没有用 final 修饰）</strong></p>\n<p><strong>StringBuffer 是线程安全的，其值可以改变，速度慢。</strong></p>\n</blockquote>\n<h3 id=\"拼接字符串\"><a class=\"anchor\" href=\"#拼接字符串\">#</a> 拼接字符串</h3>\n<blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">String</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"a\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>开辟了三个内存空间</strong></p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">StringBuilder</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>只开辟了一个内存空间</strong></p>\n<p><strong>拼接字符串不能使用 String，要是有 StringBuilder 或 StringBuffer</strong></p>\n</blockquote>\n<h2 id=\"集合\"><a class=\"anchor\" href=\"#集合\">#</a> 集合</h2>\n<h3 id=\"map\"><a class=\"anchor\" href=\"#map\">#</a> Map</h3>\n<p>可分为 HashMap 和 TreeMap</p>\n<blockquote>\n<p>HashMap：hash 表无序，不能放重复键，允许放空键空值</p>\n<p>TreeMap：数据结构是树，有序</p>\n</blockquote>\n<h3 id=\"collection\"><a class=\"anchor\" href=\"#collection\">#</a> Collection</h3>\n<p>分为 List 和 Set</p>\n<blockquote>\n<p>List：有序的，可以重复的</p>\n<p>Set：无序的，不可重复的，需要重写 equals 和 hashcode 方法</p>\n</blockquote>\n<p>List 接口：ArrayList、LinkedList</p>\n<p>Set 接口：HashSet、TreeSet</p>\n<blockquote>\n<p>HashSet：底层数据结构是哈希链表，保证元素的唯一，不保证元素顺序不变，需要使用 equals 方法和 hashcode 方法</p>\n<p>TreeSet：底层数据结构是二叉树，保证元素唯一，并对元素按自然排序进行排序，可以实现 Compareable 接口重写 compareTo () 实现自定义排序</p>\n</blockquote>\n<h3 id=\"arraylist-linkedlist和vector的区别\"><a class=\"anchor\" href=\"#arraylist-linkedlist和vector的区别\">#</a> ArrayList、LinkedList 和 vector 的区别</h3>\n<p>ArrayLsit 和 LinkedList 都是实现了 List 接口</p>\n<p>ArrayList 是基于动态数组的数据结构，LinkedList 是基于链表的</p>\n<blockquote>\n<p><strong>ArrayList：查询快，增加删除慢，由于数组在内存中是一块连续的内存，查询根据索引就能找到，所以快，而添加和删除需要移动内存，所以慢。</strong></p>\n<p><strong>LinkedList：增加删除快，查询慢，由于链表在内存中不是连续的，查找时，需要从头部开始，挨着找，所以查询慢，而添加删除时，只需要改变引用指向即可，所以增加删除快</strong></p>\n<p><strong>ArrayList：默认容量 10，每次扩容时为之前的 1.5 倍，是线程不安全的，效率高</strong></p>\n<p><strong>vector：默认容量 10，每次扩容是为之前的 2 倍，是线程安全的，效率低</strong></p>\n</blockquote>\n<h3 id=\"hashmap和hashtable的区别\"><a class=\"anchor\" href=\"#hashmap和hashtable的区别\">#</a> HashMap 和 HashTable 的区别</h3>\n<p>相同点</p>\n<blockquote>\n<p><strong>HashMap 和 HashTable 都是通过键值对来存储值的</strong></p>\n</blockquote>\n<p>不同点</p>\n<blockquote>\n<p><strong>HashMap：可以把 null 作为键或值，是线程安全的，效率较高，默认容量 16，每次扩容时为原来的两倍</strong></p>\n<p><strong>HashTable：不能把 null 作为键或值，是线程不安全的，效率较低，默认容量为 11，每次 扩容为原来的两倍加一</strong></p>\n</blockquote>\n<p>创建时，如果给定容量初始值，那么 HashTable 就是给定的初始值，而 HashMap 会自动扩充为 2 的幂次方大小</p>\n<h3 id=\"hashmap与concurrenthashmap的区别\"><a class=\"anchor\" href=\"#hashmap与concurrenthashmap的区别\">#</a> HashMap 与 concurrentHashMap 的区别</h3>\n<blockquote>\n<p><strong>concurrentHashMap 对整个 Map 进行了分段分割，分为了 N 个 Segment，默认提升 16 倍，相对于 HashTable 的 synchronized 锁粒度更精细了一些，并发性能更好，而 HashMap 没有锁机制，不是线程安全的，JDk1.8 之后 concurrentHashMap 摒弃了 Segment 的数据结构，直接采用数组 + 链表 + 红黑树的数据结构实现，并发控制使用 synchronized 和 CAS (compare and swap) 来操作</strong></p>\n</blockquote>\n<h2 id=\"io\"><a class=\"anchor\" href=\"#io\">#</a> IO</h2>\n<h3 id=\"bio-nio-aio的区别\"><a class=\"anchor\" href=\"#bio-nio-aio的区别\">#</a> BIO、NIO、AIO 的区别</h3>\n<blockquote>\n<p><strong>BIO：同步阻塞</strong></p>\n<p><strong>用户发起一个 IO 操作请求后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作之后，用户进程才能运行</strong></p>\n<p><strong>NIO：同步非阻塞</strong></p>\n<p><strong>用户发起一个 IO 操作请求后，后边可以做其他事情，但是用户进程需要时不时的询问 IO 操作是否就绪，从而引起不必要的 CPU 资源浪费</strong></p>\n<p><strong>AIO：异步非阻塞</strong></p>\n<p><strong>用户发起一个 IO 操作请求后立即返回，等 IO 操作真正完成之后，应用程序会得到 IO 操作完成的通知。</strong></p>\n</blockquote>\n<h3 id=\"实现拷贝文件的工具类使用字符流还是字节流\"><a class=\"anchor\" href=\"#实现拷贝文件的工具类使用字符流还是字节流\">#</a> 实现拷贝文件的工具类使用字符流还是字节流</h3>\n<blockquote>\n<p><strong>我们拷贝的文件不确定是只包含字符流，又可能是字节流（图片、声音、图像等），为保证通用性，要是有字节流</strong></p>\n</blockquote>\n<h2 id=\"多线程\"><a class=\"anchor\" href=\"#多线程\">#</a> 多线程</h2>\n<h3 id=\"实现线程的方式\"><a class=\"anchor\" href=\"#实现线程的方式\">#</a> 实现线程的方式</h3>\n<blockquote>\n<ol>\n<li><strong>继承 Thread 类</strong></li>\n<li><strong>实现 Runnable 接口</strong></li>\n<li><strong>实现 Callable 接口</strong></li>\n</ol>\n</blockquote>\n<p>继承拓展性不强，Java 总是单继承，如果一个类继承了 Thread 类就不能继承其他类了</p>\n<h3 id=\"线程的启动方式\"><a class=\"anchor\" href=\"#线程的启动方式\">#</a> 线程的启动方式</h3>\n<blockquote>\n<p><strong>启动线程调用 start 方法，而启动以后执行的是 run 方法</strong></p>\n</blockquote>\n<h3 id=\"区分线程\"><a class=\"anchor\" href=\"#区分线程\">#</a> 区分线程</h3>\n<blockquote>\n<p><strong>调用 setName 方法，设置一个线程名称，只是一种规范，在线程创建完成后，都需要设置名称</strong></p>\n</blockquote>\n<h3 id=\"sleep和wait的区别\"><a class=\"anchor\" href=\"#sleep和wait的区别\">#</a> sleep 和 wait 的区别</h3>\n<blockquote>\n<ol>\n<li><strong>sleep 定义在 Thread 类上，不会释放锁，使用在任何地方</strong></li>\n<li><strong>wait 定义在 object 类上，会释放锁，必须在同步方法或同步代码块中执行</strong></li>\n<li><strong>超时或调用 interrupt 方法唤醒 sleep 线程</strong></li>\n<li><strong>notify 随机唤醒一个 wait 线程，notifyall 唤醒所有 wait 线程</strong></li>\n</ol>\n</blockquote>\n<h3 id=\"synchronized和lock的区别\"><a class=\"anchor\" href=\"#synchronized和lock的区别\">#</a> synchronized 和 lock 的区别</h3>\n<blockquote>\n<p><strong>synchronized 时一个关键字，lock 是一个接口</strong></p>\n<p><strong>synchronized 可以给方法和同步代码块加锁，lock 只能给同步代码块加锁</strong></p>\n<p><strong>synchronized 无需手动获取和释放锁，发生异常时会自动解锁，不会出现死锁，lock 需要自己手动加锁和释放锁，如 lock ()、unlock ()，如果忘记使用 unlock ()，则会出现死锁，所以一般在 finally 里面加上 unlock ()</strong></p>\n</blockquote>\n<h3 id=\"synchronized和volatile的区别\"><a class=\"anchor\" href=\"#synchronized和volatile的区别\">#</a> synchronized 和 volatile 的区别</h3>\n<blockquote>\n<ol>\n<li>\n<p><strong>作用位置不同</strong></p>\n<p><strong>synchronized 修饰方法、代码块</strong></p>\n<p><strong>volatile 修饰变量</strong></p>\n</li>\n<li>\n<p><strong>作用不同</strong></p>\n<p><strong>synchronized 可以保证原子性和可见性，可能会造成线程阻塞</strong></p>\n<p><strong>volatile 仅能保证可见性，无法保证原子性，不会造成线程阻塞</strong></p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"什么是死锁如何解决\"><a class=\"anchor\" href=\"#什么是死锁如何解决\">#</a> 什么是死锁，如何解决</h3>\n<p>死锁</p>\n<blockquote>\n<p>线程 1 独占资源 a 并且尝试获取独占资源 b，而线程 2 独占资源 b 并尝试获取独占资源 a，两个线程在等待另一个资源的同时不释放资源，就形成了死锁</p>\n</blockquote>\n<p>形成死锁的四个必要条件</p>\n<blockquote>\n<ol>\n<li>互斥条件：一个资源每次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>\n<li>不剥夺资源：进程以获得的资源，在未完成之前，不能强行剥夺</li>\n<li>循环等待条件：若干个进程形成一种头尾相接的循环等待资源关系</li>\n</ol>\n</blockquote>\n<p>预防死锁</p>\n<blockquote>\n<ol>\n<li>\n<p><strong>破坏请求和保存条件</strong></p>\n<p><strong>一次性的申请所有资源，之后不再申请资源，如果不满足资源条件则得不到资源分配。</strong></p>\n<p><strong>只获得初期资源运行，之后将运行完的资源释放，请求新的资源</strong></p>\n</li>\n<li>\n<p><strong>破坏不可抢占条件</strong></p>\n<p><strong>当一个进程获取某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请</strong></p>\n</li>\n<li>\n<p><strong>破坏循环等待条件</strong></p>\n<p><strong>对资源进行排号，按照序号递增的顺序请求资源，若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源</strong></p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"线程并发库\"><a class=\"anchor\" href=\"#线程并发库\">#</a> 线程并发库</h3>\n<p>创建线程池的四种方式</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">newFixedThreadPool()</td>\n<td style=\"text-align:center\">创建固定数量的线程池</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newCachedThreadPool()</td>\n<td style=\"text-align:center\">创建缓存的线程池</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newSingleThreadExecutor()</td>\n<td style=\"text-align:center\">创建单个线程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newScheduledThreadPool()</td>\n<td style=\"text-align:center\">创建定时器线程池</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"线程池的作用\"><a class=\"anchor\" href=\"#线程池的作用\">#</a> 线程池的作用</h3>\n<blockquote>\n<ol>\n<li><strong>限定线程的个数，提高线程的可管理性</strong></li>\n<li><strong>提高响应速度</strong></li>\n<li><strong>降低资源消耗</strong></li>\n</ol>\n</blockquote>\n<h2 id=\"反射\"><a class=\"anchor\" href=\"#反射\">#</a> 反射</h2>\n<h3 id=\"什么是反射\"><a class=\"anchor\" href=\"#什么是反射\">#</a> 什么是反射</h3>\n<blockquote>\n<p><strong>程序在运行时可以通过类名获取类的所有信息</strong></p>\n</blockquote>\n<h3 id=\"反射的实现方式\"><a class=\"anchor\" href=\"#反射的实现方式\">#</a> 反射的实现方式</h3>\n<blockquote>\n<ol>\n<li><strong>Class.forName()</strong></li>\n<li><strong>类名.class</strong></li>\n<li><strong>对象.getClass ()</strong></li>\n</ol>\n</blockquote>\n<h3 id=\"反射的优缺点\"><a class=\"anchor\" href=\"#反射的优缺点\">#</a> 反射的优缺点</h3>\n<blockquote>\n<p><strong>优点：在运行期间绑定对象，提高了灵活性</strong></p>\n<p><strong>缺点：有性能有影响，他的操作总是慢于直接代码</strong></p>\n</blockquote>\n<h3 id=\"怎么实现动态代理\"><a class=\"anchor\" href=\"#怎么实现动态代理\">#</a> 怎么实现动态代理</h3>\n<p>JDK 动态代理和 Cglib 代理</p>\n<blockquote>\n<p><strong>JDK 代理是基于接口实现的</strong></p>\n<p><strong>Cglib 代理是基于继承实现的</strong></p>\n</blockquote>\n",
            "tags": [
                "面试题"
            ]
        },
        {
            "id": "https://qiyins.cn/computer/questions/course-1/spring_questions/",
            "url": "https://qiyins.cn/computer/questions/course-1/spring_questions/",
            "title": "web面试题",
            "date_published": "2020-12-15T11:21:00.000Z",
            "content_html": "<h2 id=\"get和post的区别\"><a class=\"anchor\" href=\"#get和post的区别\">#</a> Get 和 Post 的区别</h2>\n<p>get 和 post 都是 http 的请求方式，用户通过不同的请求方式来完成对资源的不同操作，get、post、put、delete 分别对应着资源的查、改、增、删四个操作，一般来说 get 用来获取资源，post 用于更新资源</p>\n<blockquote>\n<ol>\n<li><strong>get 请求提交的数据会在地址栏显示出来，post 请求不会</strong></li>\n<li><strong>由于地址栏长度有限，导致 get 传输的数据有限，而 post 不会</strong></li>\n<li><strong>安全性，post 安全性比 get 高</strong></li>\n</ol>\n</blockquote>\n<h2 id=\"对servlet的理解\"><a class=\"anchor\" href=\"#对servlet的理解\">#</a> 对 Servlet 的理解</h2>\n<blockquote>\n<p><strong>Servlet 是用 Java 程序编写的服务端程序，而这些 Servlet 都要实现 Servlet 接口，其主要功能是用于交互式的浏览和修改数据，生成动态网页</strong></p>\n<p><strong>HttpServlet 重写 doget 和 dopost 方法或者重写 service 方式可以实现对 get 和 post 请求的响应</strong></p>\n</blockquote>\n<h2 id=\"servlet的生命周期\"><a class=\"anchor\" href=\"#servlet的生命周期\">#</a> Servlet 的生命周期</h2>\n<blockquote>\n<p>加载 Servlet 的生命周期，调用 init () 进行初始化，然后调用 service () 方法来处理客户端的请求，最后调用 destroy () 终止</p>\n</blockquote>\n<h2 id=\"forward与redirect的区别\"><a class=\"anchor\" href=\"#forward与redirect的区别\">#</a> forward 与 redirect 的区别</h2>\n<blockquote>\n<ol>\n<li>forward 地址栏不会发生改变，redirect 地址栏会发生改变</li>\n<li>forward 是服务器上的行为，redirect 是客户端的行为</li>\n<li>forward 是一次请求完成的，redirect 是两次请求完成的</li>\n<li>forward 效率较高</li>\n</ol>\n</blockquote>\n<h2 id=\"jsp与servlet的相同点与不同点\"><a class=\"anchor\" href=\"#jsp与servlet的相同点与不同点\">#</a> JSP 与 Servlet 的相同点与不同点</h2>\n<blockquote>\n<p>相同点：JSP 是 Servlet 的扩展，所有的 JSP 文件最终都会被翻译成一个继承 HttpServlet 类，也就是说 JSP 最终也是一个 Servlet</p>\n<p>不同点：JSP 侧重于视图，Servlet 侧重于控制逻辑</p>\n</blockquote>\n<h2 id=\"jsp的九大内置对象与四大作用域\"><a class=\"anchor\" href=\"#jsp的九大内置对象与四大作用域\">#</a> JSP 的九大内置对象与四大作用域</h2>\n<p>九大内置对象</p>\n<blockquote>\n<p><strong>Request：客户端的请求</strong></p>\n<p><strong>Response：网页传回客户端的响应</strong></p>\n<p><strong>PageContext：网页属性的管理</strong></p>\n<p><strong>Session：会话</strong></p>\n<p><strong>Application：servlet 正在执行的内容</strong></p>\n<p><strong>Out：传递回应的输出</strong></p>\n<p><strong>Config：servlet 的架构不见</strong></p>\n<p><strong>Page：Jsp 网页本身</strong></p>\n<p><strong>Exception：针对错误的网页</strong></p>\n</blockquote>\n<p>四大作用域</p>\n<blockquote>\n<p><strong>page：只在一个页面保留数据</strong></p>\n<p><strong>request：只在一个请求中保存数据</strong></p>\n<p><strong>Session：再一次会话中保存数据，仅供单个用户使用</strong></p>\n<p><strong>Application：在整个服务器中保存数据，全部用户共享</strong></p>\n</blockquote>\n<h2 id=\"cookie与session的区别\"><a class=\"anchor\" href=\"#cookie与session的区别\">#</a> Cookie 与 Session 的区别</h2>\n<p><strong>cookie 和 session 都是会话跟踪技术</strong></p>\n<p>不同点</p>\n<blockquote>\n<ol>\n<li><strong>cookie 的数据是存在客户端的，session 的数据是存在服务器上的</strong></li>\n<li><strong>cookie 是不安全的</strong></li>\n<li><strong>session 会在一定时间内存放在服务器上，当访问增多时，会占用服务器的性能</strong></li>\n<li><strong>单个 cookie 的保存数据不能超过 4k, 很多浏览器一个站点最多存放 20 个 cookie</strong></li>\n</ol>\n</blockquote>\n<p>建议</p>\n<blockquote>\n<p><strong>将登录信息等重要信息保存在 session 中，其他信息如需保留，可以放在 cookie 中，如：购物车</strong></p>\n<p><strong>购物车最好使用 cookie，范式 cookie 实在客户端禁用的，只是要我们需要使用 cookie + 数据库的方式实现，当从 cookie 中不能取出数据时，就从数据库中取</strong></p>\n</blockquote>\n<h2 id=\"mvc的各个部分有哪些技术实现\"><a class=\"anchor\" href=\"#mvc的各个部分有哪些技术实现\">#</a> MVC 的各个部分有哪些技术实现</h2>\n<blockquote>\n<p><strong>M (Model)：模型 Javabean</strong></p>\n<p><strong>V (View)：视图 jsp、html</strong></p>\n<p><strong>C (Control)：控制器：Servlet、Action</strong></p>\n<p><strong>JSP+Servlet+Javabean 是最经典的 mvc 模式，实际上就是 model2 的实现方式，将逻辑与视图隔离开</strong></p>\n<p><strong>model1：jsp+service+dao</strong></p>\n<p><strong>model2：jsp+servlet+service+dao</strong></p>\n</blockquote>\n",
            "tags": [
                "面试题"
            ]
        }
    ]
}